---
layout: post
title: New Library for Non-Deterministic Testing
date: 
type: post
parent_id: '0'
published: false
password: ''
status: draft
categories: []
tags:
- testing
meta:
  blogger_blog: toddmeinershagen.blogspot.com
  blogger_author: Todd Meinershagen
  blogger_afd108f81ae242501ffa65d49d9298e0_permalink: '1155859615003522966'
  _rest_api_client_id: "-1"
  _rest_api_published: '1'
  _publicize_job_id: '28116626582'
  _edit_last: '2295558'
  _wpcom_is_markdown: '1'
  geo_public: '0'
author:
  login: tmeinershagen
  email: todd@meinershagen.net
  display_name: Todd Meinershagen
  first_name: ''
  last_name: ''
---
<p>I have currently been working on creating a system-level, feature test for some functionality that our company is developing to allow hospitals and health care providers to request a batch of eligibility requests for patients using a combination of Visual Studio 2012, <a href="http://www.specflow.org/specflownew/">SpecFlow 1.8</a> and <a href="http://fluentassertions.codeplex.com/">FluentAssertions</a>.  In doing so, I ran into the problem of non-deterministic time.</p>
<p>Once a user uploads a file of requests, there is not a determined amount of time for that request to get a response from a third-party provider that we use to fulfill the request.  So how do we handle the fact that we need to make some assertions at the end of the upload?  What would be nice would be to either retry assertions that fail or keep trying an assertion in the event of failure for a given timeout period.  In this case, we need to know that we can get a response within 30 seconds.</p>
<p>Enter <a href="https://github.com/toddmeinershagen/James.Testing">James.Testing</a>.  (Check it out when you get a chance.  You can download the dependency to your project from NuGet.org <a href="https://www.nuget.org/packages/James.Testing/">here</a>.</p>
<p><a href="https://github.com/toddmeinershagen/James.Testing">James.Testing</a> is a library of test utilities named after the author who wrote the book of James in the Bible.</p>
<blockquote><p>
  "Dear brothers and sisters, when troubles come your way, consider it an opportunity for great joy. For you know that when your faith is tested, your endurance has a chance to grow." <strong>(James 1:2-3)</strong>
</p></blockquote>
<p>It's a fairly apt description of what testing ought to do for our applications as well.  Source for the library can be found <a href="http://www.github.com/toddmeinershagen/james.testing">here</a>.  Below are some of its features.</p>
<h2>Action Extensions</h2>
<h3>Executing an Action with Retries</h3>
<p>Many times in integration tests, there is a non-deterministic time period between executing some initial action and asserting your expectations for the outcome.  In this case, it would be nice to have a method for automatically having the test retry your action for a number of times even though the assertion fails.  This method also supports setting a wait time in between retries so that you don't overload your system.</p>
<p><strong>Example:</strong></p>
<p>[code lang="csharp"]<br />
var counter = 0;<br />
Action action = () =&amp;gt; counter++;<br />
action.ExecuteWithRetries(times, waitTimeInSeconds);<br />
[/code]</p>
<h3>Executing an Action with a Timeout Period</h3>
<p>In other cases, you might want to execute a given action for a given time period.  For instance, if you have a requirement to expect a response within 30 seconds, you can set the maximum timeout period to 30 seconds for your assertions.  This method also allows a user to set a given wait time between executions of a given action.</p>
<p><strong>Example:</strong></p>
<p>[code lang="csharp"]<br />
var counter = 0;<br />
Action action = () =&amp;gt; counter++;<br />
action.ExecuteWithTimeout(timeoutInSeconds, waitTimeInSeconds);<br />
[/code]</p>
<h3>Executing an Action while Gulping Exceptions</h3>
<p>Sometimes when you execute an action you expect an exception to occur, but you don't want the exception to cause a failure because there is something else you need to verify.  This method will do just the trick.</p>
<p><strong>Example:</strong></p>
<p>[code lang="csharp"]<br />
var counter = 0;<br />
Action retryAction = () =&amp;gt;<br />
    {<br />
        while (counter++<br />
{<br />
    Thread.CurrentThread.CurrentCulture = new CultureInfo(&amp;quot;fr-FR&amp;quot;);<br />
    session = new Session(new LocalPhantomEnvironment());</p>
<p>    session.CurrentCulture.Name.Should().Be(&amp;quot;fr-FR&amp;quot;);<br />
};</p>
<p>action.ExecuteWithCleanup(() =&amp;gt; session.End());<br />
[/code]</p>
<h2>Wait Methods</h2>
<h3>Waiting For a Time Period</h3>
<p>Many times in multi-threaded and integration tests, you need to wait for a number of seconds or milliseconds for other events to process.  James.Testing now provides a more readable syntax for these events.</p>
<p><strong>Example:</strong></p>
<p>[code lang="csharp"]<br />
Wait.For(1).Seconds();<br />
Wait.For(250).Milliseconds();<br />
[/code]</p>
<h3>Waiting Until Something is True</h3>
<p>Sometimes in multi-threaded and integration tests, you need to wait until something is true or that some state has been updated before moving forward.  The easiest way to deal with this is to let James.Testing wait until some predicate expression has come true.</p>
<p><strong>Example:</strong></p>
<p>[code lang="csharp"]<br />
Wait.Until(() =&amp;gt; Test.Current.EventLogs.Count == 2);<br />
[/code]</p>
<p>There are cases in which a predicate may never end up being true.  By default, the Wait.Until() method has a timeout of 15 seconds.  You can also configure that when calling the API by passing in a timeout period.</p>
<p><strong>Timeout Expressed as TimeSpan</strong></p>
<p>[code lang="csharp"]<br />
Wait.Until(() =&amp;gt; Test.Current.EventLogs.Count == 2, TimeSpan.FromSeconds(5));<br />
[/code]</p>
<p><strong>Timeout Expressed as Integer - Seconds</strong></p>
<p>[code lang="csharp"]<br />
Wait.Until(() =&amp;gt; Test.Current.EventLogs.Count == 2, timeoutInSeconds);<br />
[/code]</p>
