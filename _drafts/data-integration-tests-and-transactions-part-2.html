---
layout: post
title: Data Integration Tests and Transactions - Part 2
date: 
type: post
parent_id: '0'
published: false
password: ''
status: draft
categories:
- testing
tags: []
meta:
  blogger_blog: toddmeinershagen.blogspot.com
  blogger_author: Todd Meinershagen
  blogger_afd108f81ae242501ffa65d49d9298e0_permalink: '2971845694695454778'
  _publicize_job_id: '11181715550'
  geo_public: '0'
  _edit_last: '2295558'
author:
  login: tmeinershagen
  email: todd@meinershagen.net
  display_name: Todd Meinershagen
  first_name: ''
  last_name: ''
---
<p><a href="./2014/05/data-integration-tests-and-transactions.html">Last time</a> I talked about how to use the <a href="http://msdn.microsoft.com/en-us/library/system.transactions.transactionscope.aspx">TransactionScope</a> class to handle the rollback of any changes made during a data integration test. This time, I would like to talk about another issue that will eventually come up using transactions: using <a href="http://msdn.microsoft.com/en-us/data/ef.aspx">Entity Framework</a> code-first in combination with any other data access framework while leveraging TransactionScope.</p>
<p>In our case, we use <a href="https://code.google.com/p/dapper-dot-net/">Dapper</a> to insert data before our tests and to assert things about the state of the database after exercising the <a href="http://weblogs.asp.net/scottgu/archive/2010/07/16/code-first-development-with-entity-framework-4.aspx">code-first Entity Framework</a> data layer functionality we are testing. Below is our example.</p>
<pre><code>private TransactionScope _scope;

[SetUp]
public void SetUp()
{
    _scope = new TransactionScope();
}

[TearDown]
public void TearDown()
{
    _scope.Dispose();
}

[Test]
public void test_to_demo_ef_and_dapper_connections()
{
    var person = new Person {FirstName = "Todd", LastName = "Meinershagen"};
    var sql = "INSERT INTO dbo.Persons (FirstName, LastName) ";
    sql = sql + "VALUES (@FirstName, @LastName)";

    using (var connection = new SqlConnection("a connection string"))
    {
        connection.Execute(sql, person);
    }

    var db = new PersonContext();
    var matchingPersons = 
        from p in db.Persons
        where
            (p.FirstName == person.FirstName) &amp;&amp;
            (p.LastName == person.LastName)
        select p;

    matchingPersons.FirstOrDefault().Should().NotBeNull();
}
</code></pre>
<p>Both Dapper and EF establish their own connections, and we would expect that each connection would take part in the ambient transaction being created during the [SetUp] of our test fixture.</p>
<p>Normally, this is not an issue, but when the tests are run, we get a message similar to below:</p>
<pre><code>MSDTC on server 'servername' is unavailable.
</code></pre>
<p>This can occur for any number of reasons such as the following:</p>
<ul>
<li>Opening multiple connections with same connection string to SQL Server 2005.</li>
<li>Opening multiple nested connections with same connection string to SQL Server 2008.</li>
<li>Opening multiple connection to two different SQL Server 2008 instances.</li>
</ul>
<p>In the case of our tests, we are making two connections (one for EF and one for Dapper) to SQL Server 2008 using the same connection string. Based on the guidance above, this should not force our system to escalate to MSDTC.</p>
<p>So, what is happening here?</p>
<p>After searching diligently on the internet (thank God for the internet!), I found an <a href="http://stackoverflow.com/questions/18088949/entityframeworkmue-in-entity-framework">article</a> explaining that Microsoft cleverly adds information to a code-first connection string to allow Microsoft to collect statistics from those using Azure and Entity Framework to determine what percentage use code-first as opposed to database-first. (Why Microsoft, why?) This is supposed to have been fixed in EF 6.0.</p>
<p>So, instead of using a connection string as you specified:</p>
<pre><code>Data Source=(local);
Initial catalog=LocalDb;
Integrated Security=True;
</code></pre>
<p>The system uses the following for EF:</p>
<pre><code>Data Source=(local);
Initial catalog=LocalDb;
Integrated Security=True;
Application Name=EntityFrameworkMUE
</code></pre>
<p>So, what does this mean?</p>
<p>Unfortunately, this causes our system to see the two connections (Dapper and EF) as two different connection strings and therefore, it looks like you are connecting to two different data sources which escalate to MSDTC. What a pain!</p>
<p>So, how do we get around this issue.</p>
<p>One way would be to use EF for both production and test code, although this robs us of the benefit of quickly setting up data using a light-weight framework like Dapper. Another option is to modify our test projectâ€™s configuration file by explicitly specifying the Application Name for our connection string. The system will then see the two connections as the same. No more escalation to MSDTC!</p>
<p>Hope this helps.</p>
<div class="blogger-post-footer">
<div><span style="border-top:solid 1px #000000;"><br />
<span style="text-align:left;"><br />
Todd Meinershagen is a Principal Consultant with </span><a style="text-align:left;" href="http://www.improvingenterprises.com/">Improving Enterprises</a><span style="text-align:left;"> in Dallas, Texas.</span><br />
</span></div>
</div>
